name: Deploy Application

on:
  workflow_dispatch:
  push:
    branches:
      - develop
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      deployments: write
      issues: write
      pull-requests: write
      actions: read
      checks: write
      id-token: write
    env:
      GITHUB_TOKEN: ${{ secrets.DEPLOY_TOKEN }}

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Set deployment variables
      id: vars
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "deploy_path=${{ secrets.DEPLOY_PATH }}" >> $GITHUB_OUTPUT
          echo "app_url=https://crm-app.maboussole.net" >> $GITHUB_OUTPUT
          echo "app_env=production" >> $GITHUB_OUTPUT
          echo "app_debug=false" >> $GITHUB_OUTPUT
        else
          echo "deploy_path=${{ secrets.STAGING_DEPLOY_PATH }}" >> $GITHUB_OUTPUT
          echo "app_url=https://staging-crm-app.maboussole.net" >> $GITHUB_OUTPUT
          echo "app_env=staging" >> $GITHUB_OUTPUT
          echo "app_debug=true" >> $GITHUB_OUTPUT
        fi

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Configure Known Hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -p ${{ secrets.SERVER_PORT }} ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts

    - name: Deploy Application
      env:
        DEPLOY_PATH: ${{ steps.vars.outputs.deploy_path }}
        REMOTE_USER: ${{ secrets.SERVER_USER }}
        REMOTE_HOST: ${{ secrets.SERVER_HOST }}
        REMOTE_PORT: ${{ secrets.SERVER_PORT }}
      run: |
        echo "Déploiement vers ${{ steps.vars.outputs.app_env }} en cours..."
        
        ssh -p $REMOTE_PORT $REMOTE_USER@$REMOTE_HOST "
          set -e  # Arrêter le script en cas d'erreur
          
          # Définir le chemin de déploiement
          DEPLOY_PATH='${DEPLOY_PATH}'
          
          # Vérifier que le chemin est défini
          if [ -z \"\$DEPLOY_PATH\" ]; then
            echo 'Error: DEPLOY_PATH is not set'
            exit 1
          fi
          
          echo \"Using deploy path: \$DEPLOY_PATH\"
          
          # Vérification des commandes requises
          command -v git >/dev/null 2>&1 || { echo 'git is required but not installed.' >&2; exit 1; }
          command -v composer >/dev/null 2>&1 || { echo 'composer is required but not installed.' >&2; exit 1; }
          command -v npm >/dev/null 2>&1 || { echo 'npm is required but not installed.' >&2; exit 1; }
            
          # Vérification et nettoyage du répertoire de déploiement
          echo 'Configuration du répertoire de déploiement...'
          if [ ! -d \"\$DEPLOY_PATH\" ]; then
            echo 'Error: Le répertoire de déploiement n'\''existe pas. Veuillez le créer avec les bonnes permissions.'
            exit 1
          else
            echo 'Nettoyage du répertoire de déploiement...'
            rm -rf \"\$DEPLOY_PATH\"/*
            rm -rf \"\$DEPLOY_PATH\"/.[!.]*
          fi
            
          # Navigation vers le répertoire de déploiement
          cd \"\$DEPLOY_PATH\" || exit 1
            
          # Clone du dépôt avec le token
          echo 'Clonage du dépôt...'
          git clone --depth 1 -b ${{ github.ref_name }} https://${{ secrets.DEPLOY_TOKEN }}@github.com/digitalcigit/maboussoleapp-v2.git .
            
          # Création du fichier .env
          echo 'Configuration du fichier .env...'
            
          echo 'APP_NAME=MaBoussole' > .env
          echo 'APP_ENV=${{ steps.vars.outputs.app_env }}' >> .env
          echo 'APP_KEY=${{ secrets.STAGING_APP_KEY }}' >> .env
          echo 'APP_DEBUG=${{ steps.vars.outputs.app_debug }}' >> .env
          echo 'APP_URL=${{ steps.vars.outputs.app_url }}' >> .env
          echo '' >> .env
          echo 'LOG_CHANNEL=stack' >> .env
          echo 'LOG_LEVEL=debug' >> .env
          echo '' >> .env
          echo 'DB_CONNECTION=mysql' >> .env
          echo 'DB_HOST=${{ secrets.STAGING_DB_HOST }}' >> .env
          echo 'DB_PORT=${{ secrets.STAGING_DB_PORT }}' >> .env
          echo 'DB_DATABASE=${{ secrets.STAGING_DB_DATABASE }}' >> .env
          echo 'DB_USERNAME=${{ secrets.STAGING_DB_USERNAME }}' >> .env
          echo 'DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}' >> .env
          echo '' >> .env
          echo 'BROADCAST_DRIVER=log' >> .env
          echo 'CACHE_DRIVER=file' >> .env
          echo 'FILESYSTEM_DISK=local' >> .env
          echo 'QUEUE_CONNECTION=sync' >> .env
          echo 'SESSION_DRIVER=file' >> .env
          echo 'SESSION_LIFETIME=120' >> .env

          echo 'Vérification du fichier .env...'
          cat .env

          # Installation des dépendances PHP avec plus de verbosité
          echo 'Installation des dépendances PHP...'
          composer install --no-dev --no-interaction --optimize-autoloader -v
            
          # Installation des dépendances Node.js et build avec plus de verbosité
          echo 'Installation des dépendances Node.js...'
          npm ci --verbose
          npm run build --verbose
            
          # Configuration de l'application avec plus de logs
          echo 'Configuration de l'\''application...'
            
          # Génération de la clé d'application
          echo 'Génération de la clé d'\''application...'
          php artisan key:generate --force --verbose
            
          # Création des dossiers nécessaires
          echo 'Création des dossiers nécessaires...'
          mkdir -p storage/logs
          mkdir -p storage/app/public
          mkdir -p bootstrap/cache
          
          # Configuration des permissions des dossiers
          # Note: Permissions 775/664 sont volontairement permissives pour l'environnement de staging
          # afin de faciliter le débogage et les tests. Ne pas utiliser en production.
          echo 'Configuration des permissions...'
          
          # S'assurer que tous les dossiers parents ont les bonnes permissions
          chmod 775 .
          chmod 775 storage
          chmod 775 storage/logs
          chmod 775 storage/app
          chmod 775 storage/app/public
          chmod 775 bootstrap
          chmod 775 bootstrap/cache
          
          # Configurer les permissions récursivement pour les nouveaux fichiers
          find storage -type d -exec chmod 775 {} \;
          find storage -type f -exec chmod 664 {} \;
          find bootstrap/cache -type d -exec chmod 775 {} \;
          find bootstrap/cache -type f -exec chmod 664 {} \;
          
          # Création et configuration du fichier de log
          touch storage/logs/laravel.log
          chmod 664 storage/logs/laravel.log
          
          # Vérification des permissions
          echo 'Vérification des permissions...'
          ls -la storage/logs/laravel.log
          ls -la storage/logs
          ls -la storage
          
          php artisan storage:link --force --verbose
            
          # Vérification du storage
          echo 'Vérification du storage...'
          ls -la storage
          ls -la public
            
          # Optimisations avec plus de verbosité
          echo 'Optimisation de l'\''application...'
          php artisan optimize:clear --verbose
          php artisan config:cache --verbose
          php artisan route:cache --verbose
          php artisan view:cache --verbose
            
          # Vérification des logs d'erreur
          echo 'Vérification des logs...'
          tail -n 50 storage/logs/laravel.log || echo 'Pas de fichier de log trouvé'
            
          # Migrations avec plus de verbosité
          echo 'Vérification des migrations...'
          php artisan migrate:install --verbose || echo 'Table des migrations déjà existante'
          php artisan migrate:status --verbose
          if [ \$? -eq 0 ]; then
            echo 'Exécution des migrations...'
            php artisan migrate --force --verbose
          else
            echo 'Warning: Base de données non accessible. Les migrations seront ignorées.'
          fi
            
          echo 'Déploiement terminé avec succès!'
        "

    - name: Notify Slack on Failure
      if: failure()
      run: |
        curl -X POST -H 'Content-type: application/json' --data '{
          "text": " Le déploiement sur ${{ steps.vars.outputs.app_env }} a échoué !\nBranche: ${{ github.ref_name }}\nCommit: ${{ github.sha }}"
        }' ${{ secrets.SLACK_WEBHOOK_URL }}
